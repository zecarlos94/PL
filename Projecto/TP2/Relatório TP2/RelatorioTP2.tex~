\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{listings}
\usepackage{graphicx}

\lstset{frame=Ltb,
     framerule=0pt,
     aboveskip=0.5cm,
     framextopmargin=3pt,
     framexbottommargin=3pt,
     framexleftmargin=0.4cm,
     framesep=0pt,
     rulesep=.4pt,
     stringstyle=\ttfamily,
     showstringspaces = false,
     basicstyle=\scriptsize\ttfamily,
     keywordstyle=\bf,
     numbers=left,
     numbersep=15pt,
     numberstyle=\tiny,
     numberfirstline = false,
     breaklines=true,
}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\newcommand\tab[1][1cm]{\hspace*{#1}}


\title{Processamento de Linguagens (3º ano de MiEI)\\ \textbf{Trabalho Prático 2}\\ Relatório de Desenvolvimento de uma \textit{LPIS}}
\author{Gustavo da Costa Gomes-Aluno\\ (72223) \and José Carlos da Silva Brandão Gonçalves-Aluno\\ (71223)  \and Tiago João Lopes Carvalhais-Aluno\\ (70443) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
\paragraph{}
\paragraph{}
Isto é o resumo do relatório da unidade curricular Processamento de Linguagens relativamente
ao Trabalho Prático 2.
\paragraph{}
Este visa a produção de uma linguagem de programação imperativa simples, \textit{LPIS}, e para tal será 
necessário produzir uma gramática independente de contexto \textit{GIC} com condição LR(0), 
bem como a produção do respetivo compilador, com auxílio do Gerador \textit{Yacc/Flex} e da realização de um 
conjuntos de testes, escritos na linguagem especificada na \textit{GIC}, por forma a verificar o seu correto 
funcionamento.
\paragraph{} 
E esse compilador, no final, produzirá pseudo-código assembly, que será interpretado pela máquina virtual 
e que gerará o resultado esperado.
\end{abstract}

\tableofcontents

\chapter{Introdução}
Neste trabalho todos os parâmetros exigidos foram realizados, bem como a realização de um conjunto 
de testes que foram para além dos seis testes que foram estabelecidos como requisitos minimos.
\paragraph{}
A realização desses parâmetros passou, inicialmente, por produzir uma gramática independente de 
contexto \textit{GIC} e, após a sua validação pelo docente Pedro Rangel Henriques, por criar um 
compilador que reconhecesse um ficheiro de entrada, escrito nessa linguagem, e que produzisse 
o ficheiro .vm correspondente, recorrendo ao Gerador \textit{Yacc/Flex}. Ficheiro esse que contém o
conjunto das instruções assembly para a máquina virtual.

\begin{description}
  \item [Enquadramento] Utilização do Gerador \textit{Yacc/Flex} e Desenvolvimento de uma \textit{GIC}
com o objetivo de produzir pseudo-código para a máquina virtual a partir dos padrões da linguagem 
produzida existentes num outro ficheiro.   
  \item [Estrutura do documento] Este documento possui a respectiva solução elaborada e 
uma conclusão final que une o exercício.
  \item [Resultados] Os resultados serão apreciados no capítulo vindouro e cuja solução
estará em Anexo.
  \item [Conteúdo do documento] Contém a explicação do problema em si, bem como
a apresentação da solução produzida para produzir o resultado esperado, auxiliada com 
documentação e código produzido.  
\end{description}

\section{Estrutura do Relatório} 
Este relatório possui três capítulos, uma conclusão,um capítulo extra dedicado a Anexos e a 
respectiva Bibliografia utilizada durante a realização deste projecto.
\paragraph{}
Os capítulos são Análise e Especificação do problema, Arquitectura da solução para o 
problema em questão, que envolverá a explicação das estruturas de dados utilizadas e por fim o capítulo
designado Codificação, que incluirá alguns aspectos relevantes de todos os testes realizados
para a verificação do seu correcto funcionamento. 

\chapter{Análise e Especificação}
\paragraph{}
\section{Descrição informal do problema}
Este trabalho prático pretende que o compilador produzido seja capaz de construir ficheiros com o 
pseudo-código assembly para a máquina de stack virtual(VM) fornecido pelos docentes.
\paragraph{}
Esse compilador para realizar a sua função em pleno necessita de receber como argumento
ficheiros escritos com a linguagem que também terá de ser desenvolvida e validada por um dos docentes.
A linguagem a produzir deverá permitir:
\begin{itemize}
\item Declaração e manuseamento de variáveis atómicas do tipo inteiro, com os quais se podem realizar 
as habituais operações aritméticas, relacionais e lógicas.
\item Declaração e manuseamento de variáveis estruturadas do tipo array (a 1 ou 2 dimensões, matrizes)
de inteiros, em relação aos quais é apenas permitida a operação de indexação (índice inteiro).
\item Realização de instruções algorítmicas básicas como o caso da atribuição de expressões a variáveis.
\item Leitura do standard input e escrita no standard output.
\item Realização de instruções para controlo do fluxo de execução, condicional e cíclica, que possam ser aninhadas.
\item Definição e invocação de sub programas sem parâmetros, mas que possam retornar um resultado atómico, sendo
este tópico opcional. Contudo também será produzido, e testado, por exemplo, a função "potencia(Base,Exp)".
\end{itemize}
\paragraph{}
Esta linguagem deverá ainda ter em conta que as variáveis deverão ser declaradas no início do programa e que não 
se poderá efetuar declarações nem utilizações sem declaração prévia das mesmas. Se nada for dito em relação ao valor 
que a variável toma, essa toma, por defeito, o valor zero,  após a sua declaração. 
\paragraph{}
Após se produzir essa gramática, a mesma deverá ser validada antes de se prosseguir. E por fim, após a validação 
dessa é necessário realizar as análises léxica e sintática acompanhada pelas respectivas ações
a tomar que resultarão na criação de um ficheiro com as instruções assembly correspondentes, ordenadas corretamente
por forma a produzirem o resultado final devido pela máquina de stack virtual. 
\newpage
\newpage
\section{Especificação de Requisitos}
Para iniciar a construção da gramática, em primeiro lugar, deve-se ter em conta a definição dos símbolos terminais e
não terminais, adicionando as regras de produção necessárias.\\
\\
Posto isto, seja G = \textless T, NT, S, P\textgreater a gramática para a linguagem imperativa simples (LPIS),
onde T é o conjunto dos símbolos terminais, NT o conjunto dos símbolos não ter-
minais, S o axioma da gramática e P o conjunto das regras de produção.\\
\\
Seja NUMBER a expressão regular que representa um número inteiro, NAME a que representa um nome composto por carateres
do alfabeto, podendo também conter o carater '\_' e TEXT a que representa todo o tipo de carateres de texto. Para evitar conflitos,
optámos por criar duas novas palavras reservadas, D1 e D2, que indicam a dimensão de um array. AND, OR, EQLS, DIFF, SMEQ e GTEQ representam os símbolos
"\&\&", "\texttt{|}\texttt{|}", "==", "!=, "\textless=" e "\textgreater=", respetivamente.\\
\\
Feitas as devidas apresentações, o resultado é o seguinte:\\
\\
T = \{NAME, TEXT, EQLS, DIFF, SMEQ, GTEQ, NUMBER, AND, OR, START, END, WHILE, IF, READ, PRINT, ELSE, D1, D2, ';', '[', ']', '=', '(', ')',
'\{', '\}', '+', '-', '*', '/', '\%', ',', '\textless', '\textgreater', '\$'\}\\
\\
NT = \{Program, Declarations, Body, Statement, Prints, Else, Expression, Parcel, Factor, Value, Args, MoreArgs, BooleanExpression,
BooleanFactor\}\\
\\
S = \{Program\}\\
\\
P = \{\\
\tab Program $\rightarrow$ Declarations START Body END\\ 
\\
\tab Declarations $\rightarrow$ $\epsilon$\\
\tab Declarations $\rightarrow$ NAME ';'\\ 
\tab Declarations $\rightarrow$ Declarations D1 NAME '[' NUMBER ']' ';'\\
\tab Declarations $\rightarrow$ Declarations D2 NAME '[' NUMBER ']' '[' NUMBER ']' ';'\\
\\
\tab Body $\rightarrow$ $\epsilon$\\
\tab Body $\rightarrow$ Body Statement\\
\\
\tab Statement $\rightarrow$ NAME '=' Expression ';'\\ 
\tab Statement $\rightarrow$ D1 NAME '[' Expression ']' '=' Expression ';'\\ 
\tab Statement $\rightarrow$ D2 NAME '[' Expression ']' '[' Expression ']' '=' Expression ';'\\ 
\tab Statement $\rightarrow$ WHILE '(' BooleanExpression ')' '{' Body '}' ';'\\
\tab Statement $\rightarrow$ IF '(' BooleanExpression ')' '{' Body '}' Else ';'\\
\tab Statement $\rightarrow$ READ '(' NAME ')' ';'\\
\tab Statement $\rightarrow$ READ '(' D1 NAME '[' Expression ']' ')' ';'\\
\tab Statement $\rightarrow$ READ '(' D2 NAME '[' Expression ']' '[' Expression ']' ')' ';'\\
\tab Statement $\rightarrow$ PRINT '(' Prints ')' ';'\\
\tab Statement $\rightarrow$ NAME '(' Args ')' ';'\\
\\
\tab Prints $\rightarrow$ Value\\
\tab Prints $\rightarrow$ TEXT\\
\\
\tab Else $\rightarrow$ $\epsilon$\\
\tab Else $\rightarrow$ ELSE '{' Body '}'\\
\\
\tab Expression $\rightarrow$ Parcel\\
\tab Expression $\rightarrow$ Expression '+' Parcel\\
\tab Expression $\rightarrow$ Expression '-' Parcel\\
\\
\tab Parcel $\rightarrow$ Parcel '*' Factor\\
\tab Parcel $\rightarrow$ Parcel '/' Factor\\
\tab Parcel $\rightarrow$ Parcel '\%' Factor\\
\tab Parcel $\rightarrow$ Factor\\
\\
\tab Factor $\rightarrow$ NUMBER\\
\tab Factor $\rightarrow$ Value\\
\tab Factor $\rightarrow$ '(' Expression ')'\\
\\
\tab Value $\rightarrow$ NAME\\
\tab Value $\rightarrow$ D1 NAME '[' Expression ']'\\
\tab Value $\rightarrow$ D2 NAME '[' Expression ']' '[' Expression ']'\\
\\
\tab Args $\rightarrow$ $\epsilon$\\
\tab Args $\rightarrow$ MoreArgs\\
\\
\tab MoreArgs $\rightarrow$ Value\\
\tab MoreArgs $\rightarrow$ NUMBER\\
\tab MoreArgs $\rightarrow$ MoreArgs ',' NUMBER\\
\tab MoreArgs $\rightarrow$ MoreArgs ',' Value\\
\\
\tab BooleanExpression $\rightarrow$ BooleanExpression AND BooleanFactor\\
\tab BooleanExpression $\rightarrow$ BooleanExpression OR BooleanFactor\\
\tab BooleanExpression $\rightarrow$ BooleanFactor\\
\\
\tab BooleanFactor $\rightarrow$ Expression EQLS Expression\\
\tab BooleanFactor $\rightarrow$ Expression DIFF Expression\\
\tab BooleanFactor $\rightarrow$ Expression '\textless' Expression\\
\tab BooleanFactor $\rightarrow$ Expression '\textgreater' Expression\\
\tab BooleanFactor $\rightarrow$ Expression SMEQ Expression\\
\tab BooleanFactor $\rightarrow$ Expression GTEQ Expression\\
\tab BooleanFactor $\rightarrow$ '(' BooleanExpression ')'\\
\}
\newpage
\chapter{Concepção/Desenho da Resolução}
\section{Estruturas de Dados}\\
\\
Dado não ser importante a implementação de uma estrutura de dados muito eficiente, para representar a tabela de identificadores das variáveis e guardar determinadas instruções,
o grupo optou pela criação de listas ligadas, devido à sua simplicidade.\\
\\
Primeiramente, começámos por criar a tabela de identificadores para guardar toda a informação relevante acerca das variáveis usadas, como o nome, 
o endereço na stack, o tipo e o número de colunas (para os casos do tipo ser um array, ou uma matriz). Esta estrutura revelar-se-á de extrema importância
no futuro quando for necessário inicializar novas variáveis, pois irá verificar se já estão declaradas ou não e quando for preciso ir ao seu endereço buscar o valor guadado na stack.
\begin{verbatim}
typedef struct idtable {
        char *var;		
        int type; 		
        int index;		
        int columns;		
        struct idtable *next;
} ID;

typedef struct idtable *IdTable;
\end{verbatim}
De seguida, e para conseguir fazer o aninhamento de instruções de controlo de fluxo, criámos duas estruturas de dados (listas ligadas do tipo stack) que vão guardar temporáriamente
o identificador da instrução \textit{while} ou \textit{if} em que o programa está no momento, para que, ao imprimir a instrução \textit{assembly} de final de ciclo ou de \textit{if},
possa relacioná-la com a instrução respetiva e denominá-la com o seu identificador.
\begin{verbatim}
typedef struct listwhiles {
        int numWhile;
        struct listwhiles *next;
} LWH;

typedef struct listwhiles *ListWhiles;

typedef struct listifs {
        int numIf;
        struct listifs *next;
} LIF;

typedef struct listifs *ListIfs;
\end{verbatim}
\section{Algoritmos Implementados}
Para registar ou obter informação sobre as variáveis da tabela de identificadores, foram construídas algumas funções bastante simples:
\begin{itemize}
\item \textit{insertVar}, que insere uma nova variável na tabela;
\item \textit{existVar}, verifica se uma determinada variável existe na tabela;
\item \textit{getTypeVar}, retorna o tipo de uma dada variável;
\item \textit{getVarIndex}, retorna o endereço da variável na stack;
\item \textit{getNumCols}, retorna o número de colunas de uma variável.
\end{itemize}
\newpage
\chapter{Codificação}
\section{Alternativas, Decisões e Problemas de Implementação}
\subsubsection{Operadores}
Um dos principais problemas passou pela definição da ordem com que são efetuadas as operações aritméticas. Neste caso, o grupo optou por, numa situação
em que é detetada uma expressão, dividir a mesma em fatores e parcelas, ou seja, quando há uma soma ou subtração, poderá ocorrer uma expressão somar com uma parcela, que por sua vez,
poderá ser um só valor, ou então uma multiplicação ou divisão de um fator com uma parcela. Isto irá garantir, com certezas absolutas, que os operadores com maior prioridade
irão ser executados em primeiro lugar.
\subsubsection{Aninhamento}
Outro problema encontrado (e bem mais complexo que o anterior) foi o do aninhamento de instruções de controlo de fluxo, uma vez que será sempre necessário um retrocesso.
Para dar a volta à situação, o grupo utilizou as duas stacks criadas (\textit{ListIfs} e \textit{ListWhiles}) e já explicadas anteriormente, para guardar o identificador da instrução \textit{while} ou \textit{if} em que o programa se encontra no momento. A título de exemplo, sempre que for detetado um \textit{while}, o programa faz um \textit{push} à stack com o seu identificador, ou seja, o 
primeiro que aparecer terá o número 1, o segundo o número 2, e assim sucessivamente. Quando chegar á última instrução, faz o \textit{pop} à stack com o identificador atual, que está
guardado em variável. Desta forma saber-se-à sempre a que \textit{while} ou \textit{if} correspondem as instruções atuais. Convém notar que, para evitar que duas \textit{labels} de fim de instrução apareçam sucessivamente juntas no código \textit{assembly} e comprometam o desempenho do programa, é também guardado o endereço da última instrução de fim de ciclo ou condição, para
que, quando ocorrer um caso deste tipo, se possa acrescentar a instrução \textit{nop}, que não faz absolutamente nada.
\subsubsection{Conflitos}
Ocorreu também uma situação em que, quando supostamente o programa deveria detetar uma variável como uma matriz, este detetou como sendo um array. Ora, isto ocorreu devido ao facto de as ações
impostas no \textit{Yacc} aquando da deteção de arrays e matrizes serem iguais no seu início e, por esse motivo, como a condição relativa ao array aparecia em primeiro lugar, o programa ia para lá
e ignorava a condição das matrizes. Para resolver este problema, optámos por colocar um identificador com a dimensão do array/matriz (D1 e D2, respetivamente). Desta forma garante-se que as condições serão sempre diferentes e impede o aparecimento de conflitos.
\newpage 
\section{Testes realizados e Resultados}
De seguida, serão apresentados exemplos de código na linguagem proposta, assim como o respetivo \textit{assembly} gerado para alguns dos testes propostos pela equipa docente para verificar o bom funcionamento do compilador:
\subsubsection{Lidos 3 números, escrever o maior deles}
\lstinputlisting{maxNumber.txt}
\newpage
\textit{Assembly} resultante:
\lstinputlisting{maxNumber.vm}
\newpage
\subsubsection{Ler N números, calcular e imprimir o seu somatório}
\lstinputlisting{sum.txt}
\newpage
\textit{Assembly} resultante:
\lstinputlisting{sum.vm}
\newpage
\subsubsection{Contar e imprimir os números pares de uma sequência de N números dados}
\lstinputlisting{pair.txt}
\newpage
\textit{Assembly} resultante:
\lstinputlisting{pair.vm}
\newpage
\subsubsection{Ler e armazenar os elementos de um vetor de comprimento N. Imprimir os valores por ordem crescente após fazer a ordenação do array por trocas diretas}
\lstinputlisting{orderArray.txt}
\newpage
\textit{Assembly} resultante:
\lstinputlisting{orderArray.vm}
\newpage
\subsubsection{Ler e armazenar os elementos de uma matriz NxM. Calcular e imprimir a média e máximo dessa matriz}
\lstinputlisting{matrix.txt}
\newpage
\textit{Assembly} resultante:
\lstinputlisting{matrix.vm}
\newpage
\chapter{Conclusão}
O grupo concluiu que o resultado final obtido é bom e os problemas encontrados foram todos ultrapassados. 
No que diz respeito á gramática desenvolvida pode-se concluir que cumpre todos os requisitos, incluindo o requisito
opcional e ainda que a sua expansão será fácil em muitos aspectos, como por exemplo, a evolução para outros tipos, 
que não inteiros(float,doubles,etc).
\paragraph{}
Em relação ao compilador produzido e com base nos testes mínimos que foram desenvolvidos, este constrói efetivamente
os ficheiros  com as instruções assembly na ordem correta que permite ser interpretado pela máquina de stack virtual e ainda 
obter o resultado esperado na mesma. 
\paragraph{}
Optou-se ainda por desenvolver outros testes que demonstram outras situações
comuns em que o compilador também funciona. 
\newpage
\appendix
\chapter{Ficheiro \textit{Yacc}}
\lstinputlisting{compiler.y}
\newpage
\chapter{Ficheiro \textit{Flex}}
\lstinputlisting{compiler.fl}
\newpage
\chapter{Makefile}
\lstinputlisting{Makefile}
\begin{thebibliography}{9} 
\bibitem{compilers} 
\textit{V. Aho, Alfred} , \textit{S. Lam,Monica} , \textit{Sethi,Ravi}  and \textit{D. Ullman,Jeffrey} Second Edition, 
\textit{Compilers Principles Techniques and Tools}.
\end{thebibliography}
\end{document} 
