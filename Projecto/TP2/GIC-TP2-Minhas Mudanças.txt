lpis -> declarations functions

functions -> function
           | function functions

function -> type NAME '(' input ')' '{' program '}'

input -> declarations
       | EMPTY

program -> declaration body 'return' value

declaration -> declarations ';'
             | EMPTY

// Deveria ser ‘;’ e nao ‘,’
//Por exemplo isso esta a permitir fazer 
//int a, int [] b, int [][] c
// Se for para ser diferente de C esta mt bem 
//Pq é algo diferente estéticamente, caso o objetivo
//Seja ‘imitar’ C deveria ser ‘;’

//Ainda poderia ser bom adicionar ‘define’ de expressões
// que incluiria já value
//declarations -> type NAME
//              | type NAME ',' declarations
//		 | ‘define’ NAME expression

declarations -> type NAME
              | type NAME ',' declarations


body -> atributions body
      | flowControl body
      | EMPTY

atributions -> NAME '=' expression ';' atributions
             | NAME '[' NUMBER ']' '=' expression ';' atributions
             | NAME '[' NUMBER ']' '[' NUMBER ']' '=' expression ';' atributions
             | EMPTY

// Esta mt bem mas alterava so o seguinte
// | 'if' '(' booleanExpression ')' '{' body '}' 'else' '{' body '}'
// para 
// | 'if' '(' booleanExpression ')' test
// test -> '{' body '}' 'else if’ '{' body '}'
	   | '{' body '}' 'else' '{' body '}'
//	   | '{' body '}'
// Por forma a permitir ter só if sem ter else, e ainda dar
// a possibilidade de ter if{} else if{} else{}

flowControl -> 'while' '(' booleanExpression ')' '{' body '}'
             | 'if' '(' booleanExpression ')' '{' body '}' 'else' '{' body '}'

expression -> value
            | value '+' expression
            | value '-' expression
            | value '*' expression
            | value '/' expression

booleanExpression -> value booleanSignal value
                   | value booleanSignal value '&&' booleanExpression
                   | value booleanSignal value '||' booleanExpression
//		    | ‘!’ booleanExpression
// Tratar também de operadores

booleanSignal -> '=='
               | '<'
               | '>'
               | '<='
               | '>='

values -> moreValues
        | EMPTY

moreValues -> value 
            | value ',' moreValues

// Se colocarmos os defines
// Adicionar aqui

value -> NAME
       | NUMBER
       | NAME '(' values ')'
       | NAME '[' NUMBER ']'
       | NAME '[' NUMBER ']' '[' NUMBER ']'
//     | NAME '[' NAMEDEF ']' '[' NAMEDEF ']'
//
// onde NAMEDEF é um nomes dos defines


// Esta mt bem mas acho que poderia expandir
// Para outros tipos mais gerais
//type -> 'int'
//      | ‘float’
//      | ‘bool’
//      | ‘char’
//
//subtype -> type
//	    | type ‘[]’
//	    | type ‘[][]’
// Caso se opte por esta opinião temos de mudar em ‘declarations’
//para se manter coerente(em vez de type… passaria a ser subtype…)

type -> 'int'
      | 'int[]'
      | 'int[][]'

