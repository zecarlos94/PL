\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}
\usepackage{url}
\usepackage{listings}
\usepackage{graphicx}

\lstset{
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}
%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}


\title{Processamento de Linguagens (3º ano de MiEI)\\ \textbf{Trabalho Prático 1}\\ Relatório de Desenvolvimento de um Normalizador de ficheiros \textit{BibTex}}
\author{Gustavo da Costa Gomes-Aluno\\ (72223) \and José Carlos da Silva Brandão Gonçalves-Aluno\\ (71223)  \and Tiago João Lopes Carvalhais-Aluno\\ (70443) }
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Isto é um resumo do relatório da unidade curricular Processamento de Linguagens relativamente
ao Trabalho Prático 1.
Este visa a produção de um Normalizador de ficheiros \textit{BibTex} permitindo a exploração
da ferramenta \textit{Flex} acompanhada de uma pequena demonstração de quão poderosa realmente é.
Também é possível encontrar numa seção, no capítulo "Anexo", que possui a resolução de um segundo 
enunciado, que é a conversão de ficheiros \textit{Zim-Wiki} para slides \textit{Beamer}.
\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}
Este trabalho envolveu o desenvolvimento de um Normalizador de ficheiros \textit{BibTex}, 
um dos enunciados disponibilizados, no qual se procede á sua análise tendo em conta os
seguintes pontos,
\begin{description}
  \item [Enquadramento] Utilização de Expressões Regulares e Filtros de Texto
com o objetivo de produzir novos documentos a partir de padrões existentes num
outro ficheiro.   
  \item [Estrutura do documento] Este documento possui um anexo com todo o código
produzido em cada uma das alíneas, uma conclusão final que une o exercício e as 
respectivas soluções elaboradas e ainda capítulos elucidativos de cada tarefa a
desempenhar em cada alínea.
  \item [Resultados] Os resultados serão apreciados nos respectivos capítulos
correspondentes a cada uma das alíneas desenvolvidas e cujo ficheiro(ou partes dele)
estará(ão)  no Anexo correspondente.
  \item [Conteúdo do documento] Contém a explicação do problema em si, bem como
a apresentação das soluções produzidas para colmatar essa situação, auxiliada com 
documentação e código produzido, presente nos Anexos.  
\end{description}

\section*{Estrutura do Relatório} \
Este relatório possui quatro capítulos, uma conclusão,um capítulo extra dedicado a Anexos e a respectiva
Bibliografia utilizada durante a realização deste projecto.
Os capítulos são Análise e Especificação do problema, Especificação dos Requisitos,
Arquitectura da solução para cada um dos sub-problemas indicados no enunciado global 
que envolverá a explicação das estruturas de dados utilizadas e por fim o capítulo
designado Codificação, que incluirá alguns aspectos relevantes de todos os testes realizados
para a verificação do correcto funcionamento. 

\chapter{Análise e Especificação} \label{ae}
\section{Descrição informal do problema}

\textit{BibTex} é uma ferramenta de formatação de citações bibliográficas em documentos \textit{Latex}, que separa a 
bibliografia consultada do restante conteúdo. Um exemplo desse ficheiro, com a extensão .bib ilustra-se de seguida,
\paragraph{}
\lstinputlisting{enunciado.bib} 
\paragraph{}
Este enunciado consiste em três alíneas, nas quais são requeridas diferentes tarefas a implementar.
Na alínea a é pedido que se elabore um documento \textit{HTML} que contenha a contagem de todas as 
diferentes categorias presentes no documento \VerbatimInput{lpbib.txt}, explicado num capítulo vindouro, 
\textit{Código do Programa}.
\paragraph{}
Na alínea b é pedido que se desenvolva uma ferramenta de normalização que faça \textit{pretty-printing}, fazendo 
a indentação correta em cada campo, escrevendo cada autor numa linha e que coloque no início da mesma
os campos autor e título, e quando um campo estiver entre aspas modifique para chavetas e se escreva
o nome dos autores com o seguinte formato, \textit{N.Apelido}.
\paragraph{}
Por fim, na alínea c é pedido a construção de um grafo que para um determinado autor, á escolha do
utilizador, mostre todos os autores que publicaram com esse autor. Para tal, recorrer-se-á á linguagem Dot 
do \textit{GraphViz2}, gerando um ficheiro com esse grafo de modo a que possa, posteriormente, desenhar o mesmo
através de uma outra ferramenta que faça a leitura desses ficheiros.

\section{Especificação do Requisitos}
Neste trabalho, o objectivo é estimular a utilização de um ambiente \textit{Linux}, da linguagem imperativa \textit{C}  
e de outras ferramentas de apoio para a resolução de problemas de um modo diferente do habitual, que seria
tentar resolver tudo apenas utilizando uma linguagem de programação e, para tal, visam o estudo e o 
desenvolvimento de Expressões Regulares, bem como, a sua manipulação por forma a atingir o resultado
pretendido. Essas expressões são fundamentais para encontrar os padrões para os quais se irá tomar uma
ação, que será a transformação do texto, filtrando ou removendo esses.
Como auxiliar na realização de filtros de texto recorrer-se-á á utilização de um gerador designado, \textit{Flex}.
\paragraph{}
Na realização deste problema é necessário concluir uma lista de tarefas que são, especificar os padrões de frases 
que se quer encontrar no texto fonte, através de Expressões Regulares, identificar as acções semânticas a realizar
como reacção ao reconhecimento de cada um desses padrões, identificar as estruturas de dados globais que possa 
eventualmente precisar para armazenar temporariamente a informação que se vai extraindo do texto fonte ou que se 
vai construindo á medida que o processamento avança e por fim desenvolver um filtro de texto para fazer o 
reconhecimento dos padrões identificados e proceder à transformação pretendida, com recurso ao gerador \textit{Flex}.
\subsection{Dados}
Os dados fornecidos são o ficheiro \VerbatimInput{lpbib.txt}, a ser abordado num capítulo posterior, a definição
e utilização da ferramenta \textit{Flex} e a definição de um ficheiro \textit{BibTex}, isto é, as suas características.
Para além destes, na alínea c) o ficheiro de \textit{input} utilizado é referente ao resultado da alínea b) e é tem o
nome de \textit{graphTeste.txt}.
\paragraph{}
É também fornecido o nome de ferramentas de apoio á resolução do problema, sendo neste problema, a ferramenta
\textit{GraphViz2}, que permitirá colocar graficamente a informação dos grafos criados, sendo que as interações entre 
os autores se tornam mais perceptíveis. 

\chapter{Concepção/desenho da Resolução}

\section{Estruturas de Dados}
\subsection{Alínea a}
Nesta alínea optou-se por utilizar uma \textit{hashtable} como estrutura de dados auxiliar que vai guardando as categorias
e o respectivo contador á medida que se vai encontrando um padrão no ficheiro \VerbatimInput{lpbib.txt}, ou seja, a acção
ao padrão, que permite encontrar as categorias todas ao longo de todo o contéudo.
\paragraph{}
Esta estrutura segue a lógica de \textit{Open Adressing}, isto é, através de uma função de \textit{hash} é encontrada a posição
onde se irá inserir a categoria capturada pela expressão regular e no caso de essa estar já ocupada vai tentar inserir na 
posição seguinte, e se chegar á última reinicia, visto que é \textit{circular}. 
Apenas se implementou funções essenciais, \textit{inserir}, \textit{remover}, \textit{procurar} e \textit{imprimir} o conteúdo desta
estrutura e gerar o conteúdo do ficheiro \textit{HTML} pedido. 
Para verificar se uma posição já possui ou não conteúdo basta verificar a \textit{etiqueta} associada e designada por \textit{state}, 
no Anexo encontra-se o conteúdo integral da implementação desta estrutura de dados.

\newpage
\newpage

\subsection{Alínea b}
Neste problema só é preciso guardar dados para ordenar os campos de forma a colocar o campo \textit{author} em primeiro lugar, seguido do campo \textit{title} . Uma estrutura de dados simples como um array de \textit{strings} ou mais especificamente em contexto C um array de \textit{char*} seria o suficiente para ordenar os campos. No entanto, foi optado por utilizar duas \textit{structs} que contenham toda a informação de um registo para resolver o problema. Esta opção, para além de permitir um maior controlo na formatação final do registo também simplifica o código em flex.
\paragraph{}
As duas \textit{structs} estão definidas no ficheiro \textit{prettybibtex.h}. A struct \textit{registo} contém toda a informação de um registo. O campo \textit{categoria} é usado para guardar o nome da categoria, da mesma maneira o campo \textit{chave}guarda a chave. Apesar da informação dos autores ser considerada mais um campo de uma entrada \textit{BibTeX} (não confundir com campos da struct registo) foi guardada num array de \textit{strings} separando-se dos restantes campos. Esta distinção tem duas vantagens significativas, em primeiro lugar a divisão do conteúdo do campo \textit{author} num array de \textit{strings} permite guardar o nome formatado de cada autor numa string diferente, isto facilita bastante a tarefa de imprimir um autor em cada linha. A segunda vantagem é que facilita a função de ordenação dos campos, assim só é preciso colocar o campo \textit{title} em primeiro lugar do array de \textit{Campo}. Esta componente é um array de um apontador para a \textit{struct campo} que contém um par de \textit{strings} com o nome do campo a guardar e o seu respectivo conteúdo.

\begin{verbatim}
typedef struct registo{
  char* categoria;
  char* chave;
  char** autores;
  int iautores;
  Campo* campos;
  int r;
}*Registo;

typedef struct campo{
  char* nome;
  char* valor;
}*Campo;
\end{verbatim}

\paragraph{}
Esta estruturada de dados é reutilizada a cada leitura de uma entrada \textit{BibTeX} de modo a o programa não utilizar mais memória do que efetivamente necessita. É de notar que se a memória da estrutura não fosse devidamente libertada e/ou reutilizada, o programa para ficheiros \textit{BibTeX} de elevada dimensão ocuparia uma elevada quantidade de memória possivelmente capaz de ultrapassar a memória da heap atribuída pelo \textit{Sistema Operativo} e terminar interruptamente.         

 


\newpage
\newpage

\subsection{Alínea c}
Nesta alínea, optou-se pela utilização de duas listas ligadas, uma para guardar os autores que publicaram com o autor fornecido e outra para
guardar os autores de uma publicação para, posteriormente, verificar se o autor principal lá estava contido e, em caso afirmativo, guardar-se na
primeira estrutura os outros autores, sendo que, caso um autor já exista na estrutura principal, então incrementava um contador que indica quantas vezes
esse autor fez publicações em conjunto com o principal.
\paragraph{}
O grupo optou por escolher esta estrutura de dados, uma vez que é bastante simples de implentar, tendo como uma das desvantagens a pouca eficiência na procura
e inserção de informação. Contudo, como trabalhamos com pouca quantidade de dados (em termos computacionais), chegámos à conclusão que as desvantagens da lista
ligada não se iriam fazer sentir na execução do programa. 

\newpage
\newpage

\chapter{Codificação}
\section{Alternativas, Decisões e Problemas de Implementação}
\subsection{Alínea a}
Um dos problemas de implementação passou por conseguir contabilizar as categorias 
de forma independente, isto  é, após uma análise do documento fonte \VerbatimInput{lpbib.txt}
verificou-se a existência de categorias que contem exatamente os mesmos caracteres mas 
escritos de diferentes formas.
Um exemplo disso é a categoria \textit{inproceedings} que pode também se encontrar como
\textit{InProceedings} e como \textit{INPROCEEDINGS}. Então o grande desafio foi separar esta 
categoria em três, porque apesar de terem os mesmos caracteres, elas representam a mesma 
categoria mas de forma independente visto que na contagem destas se pretende ter um resultado
que mostre o que realmente está no ficheiro fonte.
\paragraph{}
 Na fase de implementação surgiram pequenos problemas relacionados com a expressão regular
 que foi definida por forma a filtrar apenas a categoria. Visto que essa estava delimitada por dois
 caracteres, o '@' e o '{'. Por vezes \textit{yytext} não continha o conteúdo correto, o que revelava 
 que a expressão regular ainda não estava a funcionar corretamente.
\paragraph{}
Após esse problemas estarem resolvidos conseguiu-se produzir o ficheiro \textit{HTML} sem 
nenhuma dificuldade, apenas se efetuou a impressão do conteúdo da estrutura de dados
que foi armazenando as categorias e atualizando os seus contadores com a indentação 
e os \textit{headers} que permitem visualizar o ficheiro obtido num \textit{browser}.
Esse ficheiro \textit{HTML} produzido chama-se \VerbatimInput{indexA.html} e pode ser
visto no Anexo A.1, bem como o filtro de texto produzido, recorrendo á ferramenta \textit{Flex}, 
neste documento.
\paragraph{}
Para terminar falta proceder á análise das expressões regulares utilizadas e a respectiva
acção a tomar quando estas forem encontradas.

\begin{verbatim}
i.	@[a?zA?Z]+\{
ii.	.|\n
\end{verbatim}

A expressão regular ii. é para filtrar todo o texto, mas é absorvente e por isso é 
preciso muito cuidado com a sua utilização e ,associado a esta, a acção de fazer \textit{print} 
que é a acção por defeito, quando se fornece 
\begin{verbatim}
{}
\end{verbatim}

\paragraph{}
A expressão regular i. é a expressão que foi desenvolvida para a resolução do problema
pedido, contagem das categorias, que exige inicialmente a captação das categorias e apenas
das categorias presentes no ficheiro \VerbatimInput{lpbib.txt}, que contem muita mais
informação.
O objectivo desta é encontrar todos os padrões que estejam contidos entre os caracteres
 '@' e '{', visto que essa é a definição de categoria num ficheiro \textit{BibTex}.
 E como as categorias apenas podem conter letras temos de restringir os padrões encontrados 
 entre esses dois caracteres ao facto de que só podem ter letras, quer minúsculas quer
 maiúsculas, daí '[a?zA?Z]+'. O símbolo '+' refere-se á possibilidade de encontrar
 uma ou mais ocorrências, isto é, entre esses dois caracteres encontra-se apenas uma ou 
 mais letras.
 Visto que não existe nenhuma restrição quanto á forma da palavra categoria, isto é, por exemplo
 a exigência de começar por letra maiúscula e seguida apenas de letras minúsculas não é
 necessário efetuar mais nenhuma restrição ao padrão que permitirá filtrar as categorias.
 \paragraph{}
 Associado a esta, última expressão regular, está a acção de copiar o conteúdo de 
 \textit{yytext+1}, que apenas considera o texto após o '@' até  \textit{yyleng-2}, onde
 está o '{' para um  \textit{char*} local que será então inserido na estrutura de dados
 através da instrução  \textit{insertTable( ht, str, (int ?) count ) ; } sendo que \textit{count}
 é um contador inicial que apenas serve para iniciar o contador na estrutura de dados.
 Esta instrução está codificada por forma a verficar logo se a categoria já existe ou não,
 e caso exista apenas incrementa a ocorrência dessa categoria e ignora o parâmetro 
 \textit{count} recebido. E caso não exista procede então ao inicio do contador com valor de
 \textit{count} recebido e insere na estrutura de dados.
 \paragraph{}
  Por fim é necessário criar o ficheiro \textit{HTML} pretendido com o conteúdo da estrutura
  de dados que foi sendo atualizada até se chegar ao fim do ficheiro \VerbatimInput{lpbib.txt} e 
  para tal na função \textit{main} do ficheiro \VerbatimInput{tp1A.l} recorreu-se á chamada da 
  função \textit{printHashTable ( ht ) ;} que foi codificada no ficheiro \textit{hashtable.c} por forma
  a criar o ficheiro \textit{HTML} com a formatação necessária, produzindo, desse modo, o 
  resultado final desta alínea.

\newpage
\newpage

\subsection{Alínea b}
A codificação deste programa acarretou alguns desafios. Inicialmente, o grande desafio foi filtrar os campos delimitados por chavetas e aspas, no entanto os dois problemas foram resolvidos de uma maneira simples e elegante. Outro grande desafio foi a leitura e formatação do conteúdo do campo \textit{author}, este provou-se ser um problema complexo e a sua solução não tão elegante e simples como as anteriores. Isto apenas porque o conteúdo do campo pode aparecer em 2 formatos distintos mais um conjunto de casos particulares.

Para a resolução do problema foram criadas 6 variáveis de condição cujo propósito de cada uma será explicado ao longo da secção.

%x AUT CHAVE CAMPOS NOMECAMPO VALORCAMPO VALORCAMPOT2 

\paragraph{}
O estado \textit{INITIAL} tem como função identificar as entradas de \textit{BibTeX} com registos de interesse, estes são os que contêm referências bibliográficas. O \textit{BibTeX} para além das entradas de interesse contem 3 tipos de entradas \textit{@string}, \textit{@preamble} e \textit{@comment}. O ficheiro de dados deste trabalho  não contem as duas últimas entradas e, portanto, a gramática não precisou de regras para lidar com as mesmas. No entanto, para a gramática funcionar com as mesmas, basta adicionar duas regras que identifiquem as entradas e as imprimem. Essas regras e respetivas ações seriam quase identicas à primeira regra para identificar a entrada \textit{@string}. Por exemplo, para apanhar a entrada \textit{@preamble} bastaria adicionar a regra @[Pp][Rr][Ee][Aa][Mm][Bb][Ll][Ee]\{ com a ação \textit{ECHO}.
Ignorando as entradas não relevantes para o objetivo do problema, temos todas as categorias restantes iniciadas também por '@' seguidas pelo nome da categoria contendo uma sequência de uma ou mais letras maiúsculas ou minúsculas [A-Za-z]+ finalizadas com o símbolo '{' . Dada a ocorrência desse padrão é inicializada a estrutura \textit{Registo} que conterá a informação da entrada, e é já adicionado à estrutura o nome da categoria.  
Após lida a categoria, vem a leitura da chave no estado CHAVE.
\begin{verbatim}
<INITIAL>@[Ss][Tt][Rr][Ii][Nn][Gg]\{ { ECHO;}
<INITIAL>@[A-Za-z]+\{ {
registo = initRegisto();
yytext[yyleng - 1] = '\0'; yytext+=1;
registo->categoria = strdup(yytext);
BEGIN CHAVE;}
<INITIAL>.|\n { ECHO;}
\end{verbatim}

\paragraph{}
A chave está obrigatoriamente separada do próximo campo através do símpolo ',' e possivelmente contem espaços no início e fim. A regra .|\n limpa esses espaços e a regra [A-Za-z0-9:]+ filtra o id da chave. Sabe-se que a chave pode conter letras, números e o símbolo ':', no entanto, se essa informação fosse desconhecida ou a chave abrangesse um conjunto maior de símbolos, a expressão regular podia ser substituída por algo mais genérico, como por exemplo:
\begin{verbatim}
[^ ]+/, 
\end{verbatim}
Esta expressão apanharia todos os símbolos excepto o espaço até apanhar o símbolo delimitador ',', não consumindo o mesmo, uma vez que não faz parte da chave. 
Gravada a chave na estrutura \textit{registo} é inicializado o estado CAMPOS.

\begin{verbatim} 
<CHAVE>[A-Za-z0-9:]+ {registo->chave = strdup(yytext);BEGIN CAMPOS;}
<CHAVE>.|\n {}
\end{verbatim}

\paragraph{}
O estado campos tem uma função apenas que é identificar se o registo acabou ou se há mais campos. 
O registo acaba se aparecer depois do último campo o símbolo '}',o último campo pode ser finalizado com uma ',' ou não. Entre a ',' opcional e a '}' de finalização pode aparecer os símbolos '\n' e ' '. No final da entrada, é invocada a função 'printRegisto' para imprimir a \textit{struct registo} com a informação da entrada na sua totalidade, a função também liberta a memória alocada.
Caso a chaveta de finalização não apareça significa que há mais campos e dá-se a leitura do nome do próximo campo no estado \textit{NOMECAMPO}.  

\begin{verbatim} 
<CAMPOS>(","?)[\n \t]*\} { printRegisto(registo); BEGIN INITIAL;}
<CAMPOS>\,[\n \t]* {BEGIN NOMECAMPO;}
\end{verbatim}

\paragraph{}
O nome do campo pode conter letras e o símbolo '-' e é obtido pela ER [a-zA-Z]+ . O separador entre o nome do campo e o seu conteúdo é o símbolo '=' , quando este é filtrado dá-se início à leitura do conteúdo do campo no estado \textit{VALORCAMPO}.
O campo \textit{author} é tratado de maneira diferente, uma vez que um dos objetivos do trabalho é formatar nomes. Este estado identifica o campo author e dá ininício ao estado AUT que irá processar o conteúdo do campo de forma diferente dos restantes. Para além disso, o estado aproveita para facilitar o trabalho do estado AUT, cobrindo o caso do conteúdo do campo \textit{author} estar vazio e o caso do campo conter apenas um único nome.

\begin{verbatim}
<NOMECAMPO>[ ]*=[ ]* { BEGIN VALORCAMPO;}
<NOMECAMPO>[a-zA-Z-]+

<NOMECAMPO>[ ]*[Aa][Uu][Tt][Hh][Oo][Rr][ ]*=[ ]*["{][ ]*["}] // Caso vazio
<NOMECAMPO>[ ]*[Aa][Uu][Tt][Hh][Oo][Rr][ ]*=[ ]*["{]  //Dá inicio a AUT
<NOMECAMPO>[ ]*[Aa][Uu][Tt][Hh][Oo][Rr][ ]*=[ ]*["{][ ]*[^ ]+[ ]*["}]/, //Único nome
\end{verbatim}

\paragraph{}
O conteúdo do campo está sempre delimitado por aspas ou chavetas, com a exceção no caso do conteúdo ser um número ou uma única palavra. Esse caso é tratado pela expressão [a-z][A-Z][0-9]+.
Se o campo estiver delimitado por aspas o conteúdo do campo pode conter todos os símbolos possíveis. O delimitador '"' pode aparecer também no próprio campo, no entanto este tem de ser precedido pelo símbolo '\', aparecendo sempre '\"'. Devido à elevada quantidade de símbolos possíveis o problema só pode ser resolvido através da negação do conjunto de símbolos não permitidos. Portanto, o conteúdo do campo é tudo excepto o delimitador '"' com a exceção do aparecimento do símbolo '\"' que resulta na expressão regular 
\begin{verbatim}
\"([^"]("\\\""?))*\"
\end{verbatim}
Quando o campo está delimitado por chavetas a mesma técnica não pode ser utilizada uma vez que o delimitador final '}' pode aparecer livremente no conteúdo. A única restrição é que sempre que é aberta uma chaveta tem de aparecer outra a fechar. O estado identifica o delimitador '{' e dá início à variavel de condição VALORCAMPOT2. O problema é resolvido nesse estado através de um contador de chavetas abertas. Esse estado finaliza quando encontrar o símbolo '}' e o número de chavetas abertas ser 1, o que significa que o símbolo '}' está a fechar a chaveta inicial do campo. 
Finalizada a leitura do conteúdo do campo é invocado o estado CAMPOS para verificar se há mais campos no registo ou se o registo acabou.

\begin{verbatim}
<VALORCAMPO>[a-zA-Z0-9]+
<VALORCAMPO>\"([^"]("\\\""?))*\"
<VALORCAMPO>\{ 
\end{verbatim}

\paragraph{}
Este estado tem como função filtrar os nomes individuais dos autores para formatar os nomes no formato "N. Apelido". Para entender a solução é necessário conhecer as formatações dos nomes dos autores. A formatação 1 consiste nos nomes completos ou primeiro e ultimo nome de cada autor separados por "and", por exemplo "Nome Nome Apelido and Nome Apelido". Na formatação 2 os nomes dos autores também são separados por "and", no entanto o apelido do autor vem sempre em primeiro lugar, separado com uma "," do primeiro e restantes nomes, por exemplo "Apelido, Nome Nome".
O estado identifica o final do campo através do padrão '",' ou '},'. Uma vez que o símbolo '}' não é um bom delimitador, visto que os nomes podem conter chavetas o que obrigaria à contagem de chavetas abertas como feito nos outros campos. Todavia tal método aumentaria significativamente a complexidade da solução.
 A solução do problema encontra-se explicada detalhadamente de seguida, cada regra contém uma pequena explicação e a sua ação é explicada.

\begin{verbatim}
// Regra identifica o final do nome completo de um autor
<AUT>[ ]+[Aa]nd[ ]+ {
  guarda o nome e o apelido do autor 
  reinicializa as variaveis de controlo
temApelido = 0; nomeCompleto = 0; primeiroNomeParsed = 0;
}
// Identifica o final do campo
<AUT>["}],[ ]*\n { 
  guarda o nome e o apelido do último autor e salta para o estado CAMPOS
}
// Apanha o último nome do campo e não deixa consumir o padrão de saída do estado
<AUT>([^ ,"\n]("\\\""?))+/"}," {
  É lido o último nome ou apelido do registo e é invocada a função formatAuthor que lida com o nome conforme as variáveis de controlo 
  formatAuthor(); // explicado no final
}
// Identifica a formatação 2 através do padrão "Apelido,"
<AUT>([^ ,"\n]("\\\""?))+/, { 
  identifica o formato 2
  guarda o apelido
}
// Apanha os restantes nomes
<AUT>([^ ,"\n]("\\\""?))+ {
  É lido um nome ou apelido e é invocada a função formatAuthor que lida com o nome conforme as variáveis de controlo 
        formatAuthor();
}
<AUT>.|\n {
  limpa espaços, e vírgulas no caso da formatação 2 */ 
}

formatAuthor(){
  Dado um nome e o estado das variáveis de controlo, comporta-se de 3 maneiras diferentes.
  Na situação do formato2 e o nome do autor não estar completo(ter 2 nomes), identifica o nome como primeiro nome e guarda o. Coloca a flag nomeCompleto ativa.
  Na situação formato1 e primeiro nome não lido, guarda o nome como primeiro nome e ativa flag 'primeiroNomeParsed'.
  Na situação formato1 e primeiro nome lido, guarda o nome como apelido. É de notar que guarda o nome sempre na mesma variável, portanto o último nome a ser guardado vai ser efetivamente o apelido. 
}

\end{verbatim}


\newpage
\newpage



\subsection{Alínea c}
Inicialmente, o problema incidiu no pouco conhecimento do grupo acerca da linguagem \textit{Dot}, pelo que
foi necessário efetuar um estudo aprofundado sobre a linguagem em questão. Posteriormente, houve uma grande 
dificuldade em conseguir captar informação do ficheiro \VerbatimInput{lpbib.txt}, uma vez que alguns carateres 
desapareciam e, obviamente, ao fazer depois a comparação com o autor principal, este nunca surgia e, como tal, o
grafo resultante seria sempre incorreto. Mas, como o trabalho de filtrar os autores e mudar os seus nomes para o 
formato "N. Apelido", já havia sido feito, então o grupo optou por receber como \texit{input} o resultado da alínea b), que
foi guardado no ficheiro \VerbatimInput{graphTeste.txt}. Desta forma, como os autores estão todos no mesmo formato, sendo que anteriormente
uns estavam no formato "Nome Apelido" e outros em "Apelido, Nome", foi mais fácil agora proceder à recolha dos mesmos,
aproveitando o trabalho efetuado anteriormente. No Anexo encontra-se um exemplo de um ficheiro \textit{.dot} e o grafo 
resultante do mesmo. Convém referir que, para proceder à execução desta alínea, deve-se exutar o comando \textit{make ARGS="N. Autor"}.
Desta forma o programa irá executar uma \textit{Makefile}, que vai executar o programa com o argumento dado.
\paragraph{}
Iremos proceder, agora, a uma breve análise às expressões regulares utilizadas nesta alínea e respetivas ações.

\begin{verbatim}
i.	author[ ]*\=[ ]*[{"]	{linha = NULL; BEGIN AUTOR;}
ii.	<AUTOR>[\t" "\n]+	{}
iii.	<AUTOR>[^\t\n]*/"\},"	{char *authorName = strdup(yytext); linha = insert(linha, authorName);}
iv.	<AUTOR>"\},\n"		{autores = getAutores(autores, linha, author); BEGIN INITIAL;}
v.	<AUTOR>[^\t\n]+		{char *authorName = strdup(yytext); linha = insert(linha, authorName);}
vi.	.|\n			{}
vii.	<*><<EOF>>		{printAutores(); free(linha); free(autores); return 0;}
\end{verbatim}

\paragraph{}
A primeira expressão corresponde à situação em que se encontra o campo "author" de um registo. O programa inicializa a estrutura de dados 
referente aos autores encontrados num registo e entra no estado "AUTOR". A segunda expressão ocorre já dentro do estado "AUTOR" e serve apenas
para limpar carateres que estejam a mais, ou seja, espaços, TAB's ou mudanças de linha. A terceira expressão apanha qualquer carater, exceto mudanças
de linha e TAB's, eliminando as aspas, até encontrar uma chaveta para fechar o campo, apanhando assim o nome do autor (dado por \textit{yytext}) e, de seguida
efetua a inserção do mesmo na estrutura \textit{linha}. A quarta expressão regular ocorre logo após a anterior e efetua a chamada da função \textit{getAutores}, que
verifica se um autor existe na \textit{linha} e, em caso afirmativo, insere os restantes autores na estrutura principal (de nome \textit{autores}) e, de seguida,
abandona o estado "AUTOR". A quinta expressão efetua o mesmo trabalho da terceira, mas serve para autores que não sejam os últimos da lista, tendo as mesmas ações.
A sexta expressão serve para, quando no estado inicial, ignorar qualquer carater ou mudança de linha. Convém notar que, como esta expressão regular vem depois
das anteriores, não serão ignorados os carateres importantes, nomeadamente, os presentes no campo "author". Por fim, a última expressão ocorre aquando do final do
ficheiro, sendo que aí serão imprimidos os autores no ficheiro \VerbatimInput{graph.dot} e efetadas as devidas limpezas na memória, devido às estruturas criadas.
\paragraph{}
Após a criação do ficheiro \VerbatimInput{graph.dot}, será executado um comando que irá criar um ficheiro de imagem com
o grafo resultante. Convém referir, mais uma vez, que todos os comandos importantes estão contidos numa \textit{Makefile}.

\newpage
\newpage

\section{Testes realizados e Resultados}

Mostram-se a seguir alguns testes feitos (valores introduzidos) e
os respectivos resultados obtidos:
\VerbatimInput{lpbib.txt} nas diferentes alíneas deste problema.

\subsection{Alínea a}
Para este problema fizeram-se testes sucessivos até encontrar a expressão regular
que permitisse armazenar apenas a categoria na estrutura de dados evitando desse
modo que a manipulação de \textit{strings} fosse feita através de funções definidas
na linguagem \textit{C}, tal como, \textit{strtok} ou outra semelhante, uma vez que 
o objectivo é a utilização de expressões regulares que façam todo o trabalho de 
manipulação de texto.

Os testes realizados passaram todos por correr a seguinte \textit{makefile}
\paragraph{}
\lstinputlisting{makefileA} 
\paragraph{}
E de seguida efetuar
\begin{verbatim}
./tp1 < lpbib.txt
\end{verbatim}

E verificando se o resultado obtido era realmente o resultado pretendido.
Antes de se chegar ao resultado correcto teve-se de corrigir a situação de 
contagem de categorias com os mesmos caracteres mas que representavam
categorias distintas porque o que acontecia era, para cada uma dessas 
categorias o contador estava a incluir as outras, mas só mostrava as 
ocorrências de uma dessas categorias.
Por exemplo, para a categoria \textit{INPROCEEDINGS} verifica-se que no
ficheiro fonte \VerbatimInput{lpbib.txt} apenas ocorre cinco vezes, mas o que 
acontecia era que se se imprimisse o conteúdo da estrutura de dados
ela apresentava apenas essas cinco ocorrências mas o valor do contador
não correspondia á contagem real porque estava a incluir os contadores
das categorias  \textit{InProceedings} e  \textit{inproceedings}.
\paragraph{}
Como resultado final obteve-se o ficheiro \textit{HTML} com o formato 
pretendido, que é categoria x e o valor do contador para essa categoria x.
Pode ser verificada abrindo o ficheiro \VerbatimInput{lpbib.txt} e procurando
uma categoria qualquer e verificar que o número de ocorrências 
coincidem e para visualizar o aspecto da solução apenas é necessário
abrir o \VerbatimInput{indexA.html} com um \textit{browser} qualquer.

\newpage
\newpage

\subsection{Alínea b}

Para testar o programa, para além de sucessivas análises gerais do output a processar o ficheiro \textit{lpbib.txt}, foi criado um ficheiro de dimensões mais reduzidas denominado \textit{bugs.txt} com entradas \textit{BibTeX} com particularidades diferentes umas das outras. Esse ficheiro contém as várias possibilidades de formatação no campo dos autores, nomes de autores com aspas e chavetas, campos com '\n', último campo terminado com ou sem vírgula e mais.
Foi também criada uma gramática extra que filtrou com sucesso os nomes de todos os autores do ficheiro \textit{lpbib.txt} já formatado pelo programa desenvolvido.  
 


\newpage
\newpage

\subsection{Alínea c}
Para executar os vários testes à aplicação, foi corrida a seguinte \textit{Makefile}:

\paragraph{}
\lstinputlisting{makefileC}

\paragraph{}
E, de seguida, correr o seguinte comando:

\begin{verbatim}
make ARGS="J. Almeida"
\end{verbatim}

De seguida, seguem abaixo o ficheiro \textit{graph.dot} e o grafo respetivo:

\paragraph{}
\lstinputlisting{graph.dot}

\center\includegraphics[width=0.5\textwidth]{fig.png}

\newpage
\newpage

\chapter{Conclusão} \label{concl}
Como pudemos verificar ao longo da realização deste trabalho prático, o \textit{Flex} é uma ferramenta bastante
útil para efetuar um \textit{parsing} a um ficheiro que contenha informação que possa ser útil em alguma situação.

\paragraph{}
Em relação ao trabalho efetuado, o grupo demonstra-se satisfeito com o resultado final do mesmo, apesar das dificuldades
sentidas em alguns momentos. Conseguimos, numa primeira fase, proceder à contagem de todas as categorias existentes no ficheiro
\textit{BibTex} e, de seguida, efetuar a normalização dos campos e desenvolver uma ferramenta de \textit{pretty-printing}, que embelezou
o ficheiro inicial, sendo que o resultado desta tarefa revelou-se extremamente importante para a realização da última fase, que consistiu,
na criação de um grafo de todos os autores que efetuaram publicações com um autor passado como argumento.

\paragraph{}
Para além destas tarefas, ainda optamos pela realização de mais uma tarefa (explicada em anexo), que consistiu na criação de \textit{slides}
em \textit{Beamer}, utilizando para tal a ferramenta \textit{Zim-wiki}. Mais uma vez e, à semelhança da tarefa anterior, os resultados
gerados foram bastante satisfatórios, o que nos deixa bastante satisfeitos.

\paragraph{}
Futuramente, pretendemos aperfeiçoar os nossos conhecimento acerca desta e de outras ferramentas de \textit{parsing} de documentos, a fim
de estarmos habilitados a construir programas ainda mais sofisticados e de melhor qualidade. 


\appendix
\chapter{Código do Programa}
Lista-se a seguir um excerto do ficheiro \textbf{\textit{BibTex}} que foi 
utilizado para demonstrar o funcionamento, correto, do código desenvolvido
para a resolução do problema. Ficheiro esse que foi disponibilizado em 
\url{http://di.uminho.pt/~prh/lp.bib}
\paragraph{}
\paragraph{}
\lstinputlisting{lpbibShort.txt} 

\newpage
\newpage

\section{Alínea a}
O código do programa desenvolvido em \textit{Flex}, tal como está no ficheiro fonte 
\textit{tp1A.l} encontra-se de seguida.
\paragraph{}
\paragraph{}
\lstinputlisting{tp1A.l} 

\newpage
\newpage

Apesar de existirem librarias disponíveis com estruturas de dados já implementadas,
tomou-se a liberdade de reutilizar uma libraria já produzida numa unidade curricular 
anterior em vez de utilizar \textit{hsearch.h} disponível em \textit{glib2.h}.
 
O código da estrutura de dados utilizada na resolução da alínea \textit{a} deste 
problema foi desenvolvido na linguagem \textit{C} e apresenta-se de seguida 
o código na integra, que pode ser encontrado no ficheiro fonte \textit{hashtable.h}. 
Relembra-se que as operações de inserir, remover e procura nesta estrutura
de dados encontra-se em \textit{hashtable.c}.
 
Ficheiro \textit{.h},
\paragraph{}
\paragraph{}
\lstinputlisting{hashtable.h}

\newpage
\newpage

Ficheiro \textit{.c},
\paragraph{}
\paragraph{}
\lstinputlisting{hashtable.c}

\newpage
\newpage

O ficheiro com a resolução da alínea \textit{a} é apresentado em baixo, e o seu conteúdo
está no ficheiro \textit{indexA.html}.
\paragraph{}
\paragraph{}
\lstinputlisting{indexA.html}

\newpage
\newpage
\section{Alínea b}
Ficheiro \textit{ppFUNCIOONAL.l}:

\paragraph{}
\lstinputlisting{ppFUNCIOONAL.l}

\newpage
\newpage

\paragraph{}
Ficheiro \textit{prettybibtex.l}:

\paragraph{}
\lstinputlisting{prettybibtex.l}

\newpage
\newpage

\paragraph{}
Ficheiro \textit{prettybibtex.c}:

\paragraph{}
\lstinputlisting{prettybibtex.c}

\newpage
\newpage

\paragraph{}
Ficheiro \textit{prettybibtex.h}:

\paragraph{}
\lstinputlisting{prettybibtex.h}

\newpage
\newpage

\paragraph{}
Ficheiro \textit{saveGraphV2.l}:

\paragraph{}
\lstinputlisting{saveGraphV2.l}

\paragraph{}
Ficheiro \textit{bugs.txt}

\paragraph{}
\lstinputlisting{bugs.txt}


\newpage
\newpage

\section{Alínea c}
Ficheiro \textit{tp1C.fl}:

\paragraph{}
\lstinputlisting{tp1C.fl}

\paragraph{}
Ficheiro \textit{lista.c}:

\paragraph{}
\lstinputlisting{lista.c}

\paragraph{}
Ficheiro \textit{lista.h}:

\paragraph{}
\lstinputlisting{lista.h}

\newpage
\newpage

\section{Extra- Zim to Beamer}

Decidiu-se também resolver o útlimo enunciado que fiz respeito á conversão de ficheiros \textit{Zim-wiki} para 
slides \textit{Beamer}, que é uma variação de \textit{LaTex}, cujos slides são criados consoante o tipo de 
\textit{Header} lido (apenas os tipos 3,4,5 permitem criar novo slide).

Ficheiro \textit{Zim-Wiki} escrito em .txt,
\paragraph{}
\paragraph{}
\lstinputlisting{zim2beamer.txt}

\newpage
\newpage

Ficheiro \textit{Ficheiro .l } com as expressões regulares que permitem resolver o problema,
\paragraph{}
\paragraph{}
\lstinputlisting{zim2beamer.l}

\newpage
\newpage

Ficheiro \textit{Ficheiro .tex } com os slides criados a partir de \textit{zim2beamer.txt},
que representa o conteúdo de um ficheiro \textit{Zim-Wiki}.

Para criar os respetivos slides apenas bastará compilar o ficheiro .tex para se obter
o ficheiro PDF.
\paragraph{}
\paragraph{}
\lstinputlisting{zim2beamer.tex}

\newpage
\newpage

Alguns \textit{prints} do ficheiro PDF final, visto que não fazia sentido incluir um PDF dentro de outro.
Pretende-se apenas mostrar três slides que contém a maior parte das características de uma
apresentação.
\paragraph{}
\paragraph{}
 \center\includegraphics{itemize.png} 
 
 \paragraph{}
\paragraph{}
 \center\includegraphics{images.png} 
 
 \paragraph{}
\paragraph{}
 \center\includegraphics{checkBoxes.png} 
 \paragraph{}
\paragraph{}
 Durante a elaboração deste enunciado os testes realizados passaram pela geração do seus
 ficheiros PDF e ir comparando com o ficheiro .txt que possui o conteúdo de um ficheiro 
 \textit{Zim-Wiki} e observando se os slides estavam de acordo com a sua especificação.
 
 O ficheiro .l contém todo o conjunto de expressões regulares que permitem capturar os padrões
 que dizem respeito ás regras de escrita de um ficheiro \textit{zim} e as ações que toma, escrever o 
 respectivo conteúdo no ficheiro \textit{LaTex Beamer}. 
 
 Os problemas que ocorreram relacionam-se com o o facto de por vezes não estar alinhado 
 mas nada de especial. O maior problema foi apenas o facto de ao fazer "fprintf" para o 
 ficheiro .tex não colocava '\' e como tal recorreu-se á utilização do seu valor \textit{ASCII}, que é
 o número 92 e verificava-se quando surge o símbolo percentagem seguido de 'c'.
\newpage
\newpage

\begin{thebibliography}{9} 
\bibitem{compilers} 
\textit{V. Aho, Alfred} , \textit{S. Lam,Monica} , \textit{Sethi,Ravi}  and \textit{D. Ullman,Jeffrey} Second Edition, 
\textit{Compilers Principles Techniques and Tools}.
\bibitem{tutorials} 
ShareLatex examples and tutorials, \texttt{https://www.sharelatex.com}
\end{thebibliography}

\end{document} 
